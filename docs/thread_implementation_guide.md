# çº¿ç¨‹å°è£…å®æˆ˜æ€»ç»“

## é¡¹ç›®æ¦‚è¿°

æœ¬æ–‡æ¡£è®°å½•äº† **CThread ç±»å®Œæ•´å®ç°è¿‡ç¨‹**ï¼ŒåŒ…æ‹¬ï¼š
- ä»ç†è®ºåˆ°å®è·µçš„å®Œæ•´æµç¨‹
- é‡åˆ°çš„æ‰€æœ‰é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ
- æŠ€æœ¯é€‰å‹çš„æ·±åº¦åˆ†æ
- è°ƒè¯•æŠ€å·§å’Œç»éªŒæ€»ç»“

è¿™æ˜¯ç»§ `thread_advanced_concepts.md`ï¼ˆç†è®ºç¯‡ï¼‰ä¹‹åçš„**å®æˆ˜ç¯‡**ã€‚

**é¡¹ç›®ä¿¡æ¯ï¼š**
- é¡¹ç›®åç§°ï¼šGameServerFrameWork1 - çº¿ç¨‹å°è£…æ¨¡å—
- å¼€å‘æ—¶é—´ï¼š2025-11-28
- å‚è€ƒé¡¹ç›®ï¼šæ˜“æ’­æœåŠ¡å™¨ - 019ï¼šçº¿ç¨‹çš„å°è£…
- æŠ€æœ¯æ ˆï¼šC++14/20ã€pthreadã€Linux ä¿¡å·æœºåˆ¶

---

## ä¸€ã€æŠ€æœ¯é€‰å‹ä¸è®¾è®¡å†³ç­–

### 1.1 æ ¸å¿ƒæŠ€æœ¯é€‰æ‹©

#### é€‰æ‹©1ï¼šstd::function vs è‡ªå®šä¹‰ Function.h

**å†³ç­–ï¼šä½¿ç”¨ std::function**

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‰æ‹© |
|------|------|------|------|
| **è‡ªå®šä¹‰ Function.h** | æ•™å­¦ä»·å€¼é«˜ï¼Œå±•ç¤ºç±»å‹æ“¦é™¤åŸç† | ä»£ç é‡å¤šï¼Œéœ€æ‰‹åŠ¨ç®¡ç†å†…å­˜ | âŒ |
| **std::function** | ç®€æ´ï¼Œæ ‡å‡†åº“è‡ªåŠ¨ç®¡ç†å†…å­˜ï¼ŒåŠŸèƒ½å®Œæ•´ | åŸç†éšè—åœ¨æ ‡å‡†åº“å†… | âœ… |

**å…³é”®ä»£ç å¯¹æ¯”ï¼š**

```cpp
// è‡ªå®šä¹‰æ–¹æ¡ˆï¼ˆæ˜“æ’­æ•™ç¨‹ï¼‰
class CFunctionBase {
    virtual int operator()() = 0;
};

template<typename F, typename... Args>
class CFunction : public CFunctionBase {
    std::_Bindres_helper<...> m_binder;
};
CFunctionBase* m_function = new CFunction<F, Args...>(...);

// std::function æ–¹æ¡ˆï¼ˆæˆ‘ä»¬çš„é€‰æ‹©ï¼‰
std::function<int()> m_function;
m_function = [f = std::forward<F>(func),
              ...a = std::forward<Args>(args)]() mutable -> int {
    return f(a...);
};
```

**é€‰æ‹©ç†ç”±ï¼š**
1. **æœ¬è´¨ç›¸åŒ**ï¼šstd::function å†…éƒ¨å°±æ˜¯ç±»å‹æ“¦é™¤å®ç°
2. **æ›´ç®€æ´**ï¼šä¸éœ€è¦æ‰‹åŠ¨ new/delete
3. **æ›´å®‰å…¨**ï¼šRAII è‡ªåŠ¨ç®¡ç†èµ„æº
4. **æ›´ç°ä»£**ï¼šç¬¦åˆ Modern C++ å®è·µ

---

#### é€‰æ‹©2ï¼šLambda æ•è·ä¸­çš„å®Œç¾è½¬å‘

**æ ¸å¿ƒé—®é¢˜ï¼šå¦‚ä½•åœ¨ lambda ä¸­æ­£ç¡®æ•è·å‚æ•°ï¼Ÿ**

**é”™è¯¯ç‰ˆæœ¬ï¼ˆç¬¬ä¸€æ¬¡å°è¯•ï¼‰ï¼š**
```cpp
m_function = [f = std::forward<F>(func),
              ...a = std::forward<Args>(args)]() mutable -> int {
    return f(std::forward<Args>(a)...);  // âŒ é”™è¯¯ï¼
};
```

**ç¼–è¯‘é”™è¯¯ï¼š**
```
error: no matching function for call to 'forward<const char (&)[13]>(const char*&)'
```

**é—®é¢˜åˆ†æï¼š**
- **æ•è·æ—¶**ï¼š`...a = std::forward<Args>(args)` å·²ç»å®Œç¾è½¬å‘
- **è°ƒç”¨æ—¶**ï¼š`a` å·²ç»æ˜¯æ•è·çš„å˜é‡ï¼Œä¸èƒ½å†ç”¨ `std::forward<Args>(a)`
- **åŸå› **ï¼š`a` çš„ç±»å‹å·²ç»ä¸æ˜¯åŸå§‹çš„ `Args` äº†

**æ­£ç¡®ç‰ˆæœ¬ï¼š**
```cpp
m_function = [f = std::forward<F>(func),
              ...a = std::forward<Args>(args)]() mutable -> int {
    return f(a...);  // âœ… ç›´æ¥å±•å¼€å³å¯
};
```

**æŠ€æœ¯è¦ç‚¹ï¼š**
1. **æ•è·é˜¶æ®µ**ï¼šä½¿ç”¨ `std::forward<Args>(args)` ä¿æŒå€¼ç±»åˆ«
2. **è°ƒç”¨é˜¶æ®µ**ï¼šç›´æ¥ä½¿ç”¨ `a...`ï¼Œä¸å† forward
3. **åŸç†**ï¼šæ•è·åçš„å˜é‡å·²ç»æ˜¯ç¡®å®šçš„ç±»å‹ï¼Œä¸éœ€è¦å†æ¬¡æ¨å¯¼

---

#### é€‰æ‹©3ï¼šC++14 vs C++20

**é‡åˆ°çš„è­¦å‘Šï¼š**
```
warning: pack init-capture only available with '-std=c++20' or '-std=gnu++20'
```

**é—®é¢˜ï¼š**
- **å‚æ•°åŒ…æ•è·** `...a = std::forward<Args>(args)` æ˜¯ C++20 ç‰¹æ€§
- ä½¿ç”¨ C++14 ç¼–è¯‘ä¼šæœ‰è­¦å‘Šï¼ˆä½†ä»èƒ½å·¥ä½œï¼‰

**è§£å†³æ–¹æ¡ˆï¼š**
```bash
# åŸå‘½ä»¤
g++ main.cpp Thread.cpp -o test -lpthread -std=c++14

# æ”¹ä¸º C++20
g++ main.cpp Thread.cpp -o test -lpthread -std=c++20
```

**æŠ€æœ¯è¯´æ˜ï¼š**
- C++14ï¼šæ”¯æŒ lambda åˆå§‹åŒ–æ•è·ï¼Œä½†ä¸æ”¯æŒå‚æ•°åŒ…æ•è·
- C++20ï¼šå®Œæ•´æ”¯æŒå‚æ•°åŒ…æ•è·
- **æœ€ä½³å®è·µ**ï¼šä½¿ç”¨ C++20 ç¼–è¯‘ï¼Œæ¶ˆé™¤è­¦å‘Š

---

### 1.2 ä¿¡å·æœºåˆ¶è®¾è®¡

#### ä¸ºä»€ä¹ˆä½¿ç”¨ä¿¡å·ï¼Ÿ

**é—®é¢˜ï¼šå¦‚ä½•å®ç°çº¿ç¨‹çš„æš‚åœ/æ¢å¤ï¼Ÿ**

**æ–¹æ¡ˆå¯¹æ¯”ï¼š**

| æ–¹æ¡ˆ | å®ç°æ–¹å¼ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‰æ‹© |
|------|---------|------|------|------|
| **è½®è¯¢æ£€æŸ¥** | ç”¨æˆ·ä»»åŠ¡ä¸­æ‰‹åŠ¨è°ƒç”¨ CheckPause() | 0 CPU æ¶ˆè€— | ä¾µå…¥æ€§å¼ºï¼Œç”¨æˆ·å¿…é¡»é…åˆ | âŒ |
| **ä¿¡å·æœºåˆ¶** | pthread_kill + sigaction | è‡ªåŠ¨æš‚åœï¼Œç”¨æˆ·æ— éœ€é…åˆ | æ¯ 1ms æ£€æŸ¥ä¸€æ¬¡ | âœ… |
| **pthread_suspend** | ç³»ç»ŸæŒ‚èµ·ï¼ˆä¸å­˜åœ¨ï¼‰ | å®Œç¾ | Linux æ²¡æœ‰æ­¤ API | âŒ |

**æˆ‘ä»¬çš„è®¾è®¡ï¼šä¿¡å· + è½®è¯¢å¾ªç¯**

```cpp
// æš‚åœï¼šå‘é€ SIGUSR1
Pause() {
    m_bpaused = true;
    pthread_kill(m_thread, SIGUSR1);
}

// ä¿¡å·å¤„ç†ï¼šé™·å…¥å¾ªç¯
Sigaction(SIGUSR1) {
    while (m_bpaused) {  // è½®è¯¢æ ‡å¿—
        if (m_thread == 0) pthread_exit(NULL);  // æ”¯æŒ Stop
        usleep(1000);  // ç¡çœ  1msï¼ŒCPU å ç”¨ < 0.01%
    }
}

// æ¢å¤ï¼šæ”¹æ ‡å¿—å³å¯
Pause() {
    m_bpaused = false;  // å¾ªç¯è‡ªåŠ¨é€€å‡º
}
```

**è®¾è®¡å“²å­¦ï¼š**
- **ç®€å•å®ç”¨**ï¼šè™½ç„¶ä¸æ˜¯"çœŸæ­£çš„æŒ‚èµ·"ï¼Œä½†è¶³å¤Ÿå¥½ç”¨
- **æ— ä¾µå…¥**ï¼šç”¨æˆ·ä»»åŠ¡æ— éœ€ä»»ä½•é…åˆ
- **CPU å‹å¥½**ï¼šæ¯ 1ms æ£€æŸ¥ä¸€æ¬¡ï¼Œå‡ ä¹ä¸æ¶ˆè€— CPU

---

#### ä¿¡å·é€‰æ‹©ï¼šSIGUSR1 vs SIGUSR2

**Linux é¢„å®šä¹‰çš„ç”¨æˆ·ä¿¡å·ï¼š**

| ä¿¡å· | ç¼–å· | é»˜è®¤è¡Œä¸º | æˆ‘ä»¬çš„ç”¨é€” |
|------|------|---------|-----------|
| **SIGUSR1** | 10 | ç»ˆæ­¢è¿›ç¨‹ | æš‚åœçº¿ç¨‹ |
| **SIGUSR2** | 12 | ç»ˆæ­¢è¿›ç¨‹ | å¼ºåˆ¶é€€å‡º |

**ä¸ºä»€ä¹ˆè¿™æ ·åˆ†é…ï¼Ÿ**
1. **SIGUSR1**ï¼šå¯é€†æ“ä½œï¼ˆæš‚åœ/æ¢å¤ï¼‰
2. **SIGUSR2**ï¼šä¸å¯é€†æ“ä½œï¼ˆå¼ºåˆ¶ç»ˆæ­¢ï¼‰
3. **è¯­ä¹‰æ¸…æ™°**ï¼šä¸€çœ¼çœ‹å‡ºä¿¡å·çš„ç”¨é€”

---

## äºŒã€å®ç°è¿‡ç¨‹ä¸é—®é¢˜è§£å†³

### 2.1 é™æ€æ˜ å°„è¡¨è®¾è®¡

#### é—®é¢˜ï¼šstatic å‡½æ•°å¦‚ä½•è®¿é—®å¯¹è±¡ï¼Ÿ

**åœºæ™¯ï¼š**
```cpp
static void Sigaction(int signo, ...) {
    // âŒ æ²¡æœ‰ this æŒ‡é’ˆï¼
    // æ€ä¹ˆè®¿é—® m_bpaused æˆå‘˜å˜é‡ï¼Ÿ
}
```

**è§£å†³æ–¹æ¡ˆï¼šé™æ€æ˜ å°„è¡¨**

```cpp
class CThread {
    static std::map<pthread_t, CThread*> m_mapThread;
};

// Start() ä¸­æ³¨å†Œ
m_mapThread[m_thread] = this;

// Sigaction ä¸­æŸ¥æ‰¾
pthread_t tid = pthread_self();
CThread* obj = m_mapThread[tid];
obj->m_bpaused;  // âœ… ç°åœ¨å¯ä»¥è®¿é—®äº†
```

**å…³é”®é—®é¢˜è§£ç­”ï¼š**

**Q1: ä¸ºä»€ä¹ˆæ˜¯ CThread*ï¼ˆæŒ‡é’ˆï¼‰è€Œä¸æ˜¯ CThreadï¼ˆå¯¹è±¡ï¼‰ï¼Ÿ**

A: ä¸‰ä¸ªåŸå› ï¼š
1. **éœ€è¦ä¿®æ”¹åŸå¯¹è±¡**ï¼šå­˜å¯¹è±¡ä¼šæ‹·è´ï¼Œä¿®æ”¹çš„æ˜¯å‰¯æœ¬
2. **å†…å­˜å¼€é”€å°**ï¼šæŒ‡é’ˆåªå  4-8 å­—èŠ‚
3. **é¿å…æ‹·è´**ï¼šCThread å¯èƒ½å¾ˆå¤§ï¼ˆåŒ…å« std::functionï¼‰

**Q2: ä¸ºä»€ä¹ˆå¿…é¡»æ˜¯ staticï¼Ÿ**

A: å› ä¸º Sigaction æ˜¯ static çš„ï¼š
- static å‡½æ•°æ²¡æœ‰ this æŒ‡é’ˆ
- éœ€è¦å…¨å±€æŸ¥æ‰¾æœºåˆ¶
- æ‰€æœ‰çº¿ç¨‹å…±äº«åŒä¸€ä¸ª map

**å†…å­˜å¸ƒå±€ï¼š**
```
å…¨å±€é™æ€åŒºï¼š
CThread::m_mapThread = {
    12345 â†’ 0x1000 (çº¿ç¨‹1å¯¹è±¡),
    12346 â†’ 0x2000 (çº¿ç¨‹2å¯¹è±¡),
    12347 â†’ 0x3000 (çº¿ç¨‹3å¯¹è±¡)
}

çº¿ç¨‹1å¯¹è±¡ (0x1000)     çº¿ç¨‹2å¯¹è±¡ (0x2000)     çº¿ç¨‹3å¯¹è±¡ (0x3000)
â”œâ”€ m_function         â”œâ”€ m_function          â”œâ”€ m_function
â”œâ”€ m_thread = 12345   â”œâ”€ m_thread = 12346    â”œâ”€ m_thread = 12347
â””â”€ m_bpaused          â””â”€ m_bpaused           â””â”€ m_bpaused
```

---

### 2.2 ä¿¡å·æ³¨å†Œä¸å¤„ç†

#### é—®é¢˜ï¼šå†…æ ¸å¦‚ä½•çŸ¥é“è°ƒç”¨å“ªä¸ªç±»çš„ Sigactionï¼Ÿ

**ç”¨æˆ·æé—®ï¼š**
> "é‚£å†…æ ¸æ€ä¹ˆçŸ¥é“æ˜¯è°ƒç”¨ CThread è¿™ä¸ªç±»é‡Œçš„ ThreadEntry è€Œä¸æ˜¯åˆ«çš„ç±»é‡Œçš„å‘¢ï¼Ÿ"

**å…³é”®ç†è§£ï¼š**

**1. å†…æ ¸ä¸çŸ¥é“"ç±»"ï¼ŒåªçŸ¥é“"åœ°å€"**

```cpp
// æ³¨å†Œæ—¶
act.sa_sigaction = &CThread::Sigaction;  // å–å‡½æ•°åœ°å€
sigaction(SIGUSR1, &act, NULL);

// ç¼–è¯‘å™¨åšçš„äº‹ï¼š
&CThread::Sigaction â†’ 0x00401234ï¼ˆå†…å­˜åœ°å€ï¼‰

// å†…æ ¸è®°å½•çš„ï¼š
SIGUSR1 â†’ 0x00401234
```

**2. ä¸åŒç±»çš„åŒåå‡½æ•°æœ‰ä¸åŒçš„åœ°å€**

```cpp
// Name Manglingï¼ˆåç§°ä¿®é¥°ï¼‰
CThread::Sigaction      â†’ _ZN7CThread9SigactionE...  (åœ°å€ 0x401234)
COtherThread::Sigaction â†’ _ZN12COtherThread9SigactionE... (åœ°å€ 0x401678)
```

**3. æ¯ä¸ªçº¿ç¨‹ç‹¬ç«‹æ³¨å†Œ**

```cpp
// çº¿ç¨‹1ï¼ˆCThreadï¼‰
ThreadEntry() {
    act.sa_sigaction = &CThread::Sigaction;      // 0x401234
    sigaction(SIGUSR1, &act, NULL);
}

// çº¿ç¨‹2ï¼ˆCOtherThreadï¼‰
ThreadEntry() {
    act.sa_sigaction = &COtherThread::Sigaction; // 0x401678
    sigaction(SIGUSR1, &act, NULL);
}

// å†…æ ¸çš„ä¿¡å·è¡¨ï¼ˆæ¯ä¸ªçº¿ç¨‹ç‹¬ç«‹ï¼‰
çº¿ç¨‹1: SIGUSR1 â†’ 0x401234 (CThread::Sigaction)
çº¿ç¨‹2: SIGUSR1 â†’ 0x401678 (COtherThread::Sigaction)
```

**æµç¨‹å›¾ï¼š**
```
ä¸»çº¿ç¨‹: pthread_kill(thread1, SIGUSR1)
    â†“
å†…æ ¸: æŸ¥è¯¢çº¿ç¨‹1çš„ä¿¡å·è¡¨
    â†“
å†…æ ¸: SIGUSR1 â†’ 0x401234
    â†“
CPU: è·³è½¬åˆ° 0x401234 æ‰§è¡Œ
    â†“
æ‰§è¡Œ CThread::Sigaction çš„æœºå™¨ç 
```

---

### 2.3 ç«æ€æ¡ä»¶é—®é¢˜

#### é—®é¢˜ï¼šç¨‹åºåœä½ï¼Œ"User defined signal 1" å¼‚å¸¸

**ç°è±¡ï¼š**
```
[ä¸»çº¿ç¨‹] å‡†å¤‡æš‚åœçº¿ç¨‹ï¼
[è°ƒè¯•] æš‚åœçº¿ç¨‹ 140737345746496
[è°ƒè¯•] SIGUSR1 ä¿¡å·å·²å‘é€
[ä¸»çº¿ç¨‹] Pause() è°ƒç”¨æˆåŠŸ
[ä¸»çº¿ç¨‹] çº¿ç¨‹å·²æš‚åœï¼Œç­‰å¾…3ç§’...
â† ç¨‹åºåœåœ¨è¿™é‡Œï¼å¼‚å¸¸ï¼šUser defined signal 1
```

**é—®é¢˜åˆ†æï¼š**

æ²¡æœ‰çœ‹åˆ° `[è°ƒè¯•] Sigaction è¢«è°ƒç”¨`ï¼Œè¯´æ˜**ä¿¡å·å¤„ç†å‡½æ•°æ²¡æœ‰æ³¨å†ŒæˆåŠŸ**ï¼

**æ—¶é—´ç«äº‰ï¼ˆRace Conditionï¼‰ï¼š**

```
ä¸»çº¿ç¨‹                          æ–°çº¿ç¨‹ï¼ˆThreadEntryï¼‰
â”€â”€â”€â”€â”€â”€â”€                         â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Start()
  â””â†’ pthread_create()
  â””â†’ è¿”å›                        å¼€å§‹æ‰§è¡Œï¼ˆå¼‚æ­¥ï¼ï¼‰
                                æ­£åœ¨æ³¨å†Œä¿¡å·...ï¼ˆè¿˜æ²¡å®Œæˆï¼‰
sleep(3) å®Œæˆ
Pause()
  â””â†’ pthread_kill(SIGUSR1) âŒ   ä¿¡å·åˆ°è¾¾ï¼Œä½†å¤„ç†å‡½æ•°è¿˜æ²¡æ³¨å†Œï¼
                                é»˜è®¤è¡Œä¸ºï¼šç»ˆæ­¢è¿›ç¨‹ ğŸ’¥
```

**è§£å†³æ–¹æ¡ˆï¼š**

```cpp
// åœ¨ Start() åç­‰å¾…
t2.Start();
sleep(1);  // â† ç»™ ThreadEntry æ—¶é—´æ³¨å†Œä¿¡å·
Pause();   // â† ç°åœ¨å®‰å…¨äº†
```

**æ›´ä¼˜æ–¹æ¡ˆï¼ˆç”Ÿäº§ç¯å¢ƒï¼‰ï¼š**

ä½¿ç”¨æ¡ä»¶å˜é‡æˆ–åŸå­å˜é‡æ ‡è®°æ³¨å†Œå®Œæˆï¼š

```cpp
class CThread {
    std::atomic<bool> m_signal_ready{false};
};

ThreadEntry() {
    // æ³¨å†Œä¿¡å·...
    m_signal_ready = true;  // â† æ ‡è®°å®Œæˆ

    EnterThread();
}

Pause() {
    while (!m_signal_ready) {  // â† ç­‰å¾…æ³¨å†Œå®Œæˆ
        usleep(100);
    }
    pthread_kill(m_thread, SIGUSR1);
}
```

---

### 2.4 è°ƒè¯•å™¨å¹²æ‰°é—®é¢˜

#### é—®é¢˜ï¼šVS è°ƒè¯•æ—¶ç¨‹åºåœä½ï¼Œéœ€è¦æ‰‹åŠ¨ç‚¹"ç»§ç»­"

**ç”¨æˆ·æé—®ï¼š**
> "ä¸ºä»€ä¹ˆéœ€è¦æˆ‘ä»¬æ‰‹åŠ¨æ“ä½œï¼Ÿæˆ‘ä»¬å†™çš„ä¸æ˜¯ç¡çœ å¾ªç¯å—ï¼Ÿ"

**çœŸç›¸ï¼šè¿™ä¸æ˜¯ä»£ç é—®é¢˜ï¼Œæ˜¯ VS è°ƒè¯•å™¨çš„è¡Œä¸ºï¼**

**è°ƒè¯•å™¨çš„èŒè´£ï¼š**
```
VS è°ƒè¯•å™¨ï¼š
    â†“
æ£€æµ‹åˆ°ä¿¡å·ï¼ˆSIGUSR1ï¼‰
    â†“
"è¿™å¯èƒ½æ˜¯å¼‚å¸¸ï¼Œæš‚åœç¨‹åºè®©ç”¨æˆ·æ£€æŸ¥"
    â†“
ç­‰å¾…ç”¨æˆ·ç‚¹å‡»"ç»§ç»­"
    â†“
é‡Šæ”¾æ§åˆ¶ï¼Œå†…æ ¸ç»§ç»­è°ƒç”¨ Sigaction
```

**å¯¹æ¯”ï¼šæœ‰/æ— è°ƒè¯•å™¨**

| ç¯å¢ƒ | è¡Œä¸º |
|------|------|
| **F5ï¼ˆè°ƒè¯•ï¼‰** | é‡åˆ°ä¿¡å· â†’ è°ƒè¯•å™¨æš‚åœ â†’ ç‚¹"ç»§ç»­" â†’ Sigaction æ‰§è¡Œ |
| **Ctrl + F5ï¼ˆä¸è°ƒè¯•ï¼‰** | é‡åˆ°ä¿¡å· â†’ ç›´æ¥è°ƒç”¨ Sigaction â†’ æµç•…è¿è¡Œ âœ… |
| **è¿œç¨‹ Linux ç»ˆç«¯** | é‡åˆ°ä¿¡å· â†’ ç›´æ¥è°ƒç”¨ Sigaction â†’ æµç•…è¿è¡Œ âœ… |

**è§£å†³æ–¹æ¡ˆï¼š**

**æ–¹æ¡ˆ1ï¼šé…ç½® VS å¿½ç•¥ä¿¡å·ï¼ˆå¦‚æœæœ‰é€‰é¡¹ï¼‰**
- `è°ƒè¯•` â†’ `å¼‚å¸¸è®¾ç½®` â†’ å–æ¶ˆå‹¾é€‰ SIGUSR1/SIGUSR2

**æ–¹æ¡ˆ2ï¼šé…ç½® GDBï¼ˆVS ä½¿ç”¨ GDB æ—¶ï¼‰**

åˆ›å»º `~/.gdbinit` æ–‡ä»¶ï¼š
```bash
handle SIGUSR1 nostop noprint pass
handle SIGUSR2 nostop noprint pass
```

**æ–¹æ¡ˆ3ï¼šä½¿ç”¨è¿œç¨‹ç»ˆç«¯è¿è¡Œï¼ˆæ¨èï¼‰**
```bash
cd ~/projects/GameServerFrameWork1
g++ main.cpp Thread.cpp -o test -lpthread -std=c++20
./test  # ä¸ä¼šè¢«è°ƒè¯•å™¨å¹²æ‰°
```

**å…³é”®ç†è§£ï¼š**
- âœ… ä»£ç å®Œå…¨æ­£ç¡®
- âœ… ä¿¡å·å¤„ç†æ­£å¸¸å·¥ä½œ
- âŒ åªæ˜¯è°ƒè¯•å™¨å¤ª"å…³å¿ƒ"ç¨‹åºäº†

---

## ä¸‰ã€å®Œæ•´ä»£ç å®ç°

### 3.1 Thread.hï¼ˆå®Œæ•´ç‰ˆï¼‰

```cpp
#pragma once
#include <pthread.h>
#include <signal.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>
#include <cstdio>
#include <functional>
#include <map>
#include <memory.h>

class CThread
{
public:
    // é»˜è®¤æ„é€ 
    CThread() : m_thread(0), m_bpaused(false) {}

    // å¸¦å‚æ•°æ„é€ ï¼ˆå®Œç¾è½¬å‘ï¼‰
    template<typename F, typename... Args>
    CThread(F&& func, Args&&... args)
        : m_thread(0), m_bpaused(false)
    {
        m_function = [f = std::forward<F>(func),
                      ...a = std::forward<Args>(args)]() mutable -> int {
            return f(a...);  // ç›´æ¥ä½¿ç”¨æ•è·çš„å˜é‡
        };
    }

    ~CThread() {}

    // ç¦ç”¨æ‹·è´
    CThread(const CThread&) = delete;
    CThread& operator=(const CThread&) = delete;

    // è®¾ç½®ä»»åŠ¡å‡½æ•°
    template<typename F, typename... Args>
    int SetThreadFunc(F&& func, Args&&... args) {
        m_function = [f = std::forward<F>(func),
                      ...a = std::forward<Args>(args)]() mutable -> int {
            return f(a...);
        };
        return 0;
    }

    // å¯åŠ¨çº¿ç¨‹
    int Start() {
        if (!m_function) return -1;
        if (m_thread != 0) return -2;

        pthread_attr_t attr;
        int ret = pthread_attr_init(&attr);
        if (ret != 0) return -3;

        ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
        if (ret != 0) return -4;

        ret = pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);
        if (ret != 0) return -5;

        ret = pthread_create(&m_thread, &attr, &CThread::ThreadEntry, this);
        if (ret != 0) return -6;

        m_mapThread[m_thread] = this;

        ret = pthread_attr_destroy(&attr);
        if (ret != 0) return -7;

        return 0;
    }

    // åœæ­¢çº¿ç¨‹ï¼ˆç¤¼è²Œç­‰å¾… + å¼ºåˆ¶ç»ˆæ­¢ï¼‰
    int Stop() {
        if (m_thread != 0) {
            pthread_t thread = m_thread;
            m_thread = 0;  // é€šçŸ¥çº¿ç¨‹é€€å‡º

            timespec ts;
            ts.tv_sec = 0;
            ts.tv_nsec = 100 * 1000000;  // 100ms

            int ret = pthread_timedjoin_np(thread, NULL, &ts);
            if (ret == ETIMEDOUT) {
                pthread_detach(thread);
                pthread_kill(thread, SIGUSR2);  // å¼ºåˆ¶ç»ˆæ­¢
            }
        }
        return 0;
    }

    // æš‚åœ/æ¢å¤ï¼ˆå¼€å…³ï¼‰
    int Pause() {
        if (m_thread == 0) return -1;

        if (m_bpaused) {
            m_bpaused = false;  // æ¢å¤ï¼šåªæ”¹æ ‡å¿—
            return 0;
        }

        m_bpaused = true;  // æš‚åœï¼šæ”¹æ ‡å¿— + å‘ä¿¡å·
        int ret = pthread_kill(m_thread, SIGUSR1);
        if (ret != 0) {
            m_bpaused = false;
            return -2;
        }
        return 0;
    }

    bool isValid() const { return m_thread != 0; }

private:
    // çº¿ç¨‹å…¥å£ï¼ˆé™æ€ï¼‰
    static void* ThreadEntry(void* arg) {
        CThread* thiz = (CThread*)arg;

        // æ³¨å†Œä¿¡å·å¤„ç†
        struct sigaction act;
        memset(&act, 0, sizeof(act));
        sigemptyset(&act.sa_mask);
        act.sa_flags = SA_SIGINFO;
        act.sa_sigaction = &CThread::Sigaction;
        sigaction(SIGUSR1, &act, NULL);
        sigaction(SIGUSR2, &act, NULL);

        // æ‰§è¡Œç”¨æˆ·ä»»åŠ¡
        thiz->EnterThread();

        // æ¸…ç†
        if (thiz->m_thread) {
            thiz->m_thread = 0;
        }

        pthread_t thread = pthread_self();
        auto it = m_mapThread.find(thread);
        if (it != m_mapThread.end()) {
            m_mapThread[thread] = nullptr;
        }

        pthread_detach(thread);
        pthread_exit(NULL);
    }

    // æ‰§è¡Œç”¨æˆ·ä»»åŠ¡
    void EnterThread() {
        if (m_function) {
            int ret = m_function();
            if (ret != 0) {
                printf("%s(%d):[%s] ret = %d\n",
                       __FILE__, __LINE__, __FUNCTION__, ret);
            }
        }
    }

    // ä¿¡å·å¤„ç†ï¼ˆé™æ€ï¼‰
    static void Sigaction(int signo, siginfo_t* info, void* context) {
        if (signo == SIGUSR1) {
            pthread_t thread = pthread_self();
            auto it = m_mapThread.find(thread);

            if (it != m_mapThread.end() && it->second) {
                while (it->second->m_bpaused) {
                    if (it->second->m_thread == 0) {
                        pthread_exit(NULL);
                    }
                    usleep(1000);  // 1ms
                }
            }
        }
        else if (signo == SIGUSR2) {
            pthread_exit(NULL);  // å¼ºåˆ¶é€€å‡º
        }
    }

    // æˆå‘˜å˜é‡
    std::function<int()> m_function;
    pthread_t m_thread;
    bool m_bpaused;
    static std::map<pthread_t, CThread*> m_mapThread;
};
```

### 3.2 Thread.cpp

```cpp
#include "Thread.h"

// å®šä¹‰é™æ€æˆå‘˜å˜é‡
std::map<pthread_t, CThread*> CThread::m_mapThread;
```

---

## å››ã€æµ‹è¯•ä¸éªŒè¯

### 4.1 æµ‹è¯•ç”¨ä¾‹è®¾è®¡

```cpp
// æµ‹è¯•ä»»åŠ¡
int PausableTask() {
    printf("[ä»»åŠ¡2] çº¿ç¨‹å¯åŠ¨\n");
    for (int i = 0; i < 20; i++) {
        printf("[ä»»åŠ¡2] å·¥ä½œä¸­... %d/20\n", i + 1);
        sleep(1);
    }
    printf("[ä»»åŠ¡2] ä»»åŠ¡å®Œæˆï¼\n");
    return 0;
}

// æµ‹è¯•ä»£ç 
int TestThread() {
    CThread t2(PausableTask);

    t2.Start();
    sleep(1);  // ç­‰å¾…ä¿¡å·æ³¨å†Œ

    sleep(3);  // è¿è¡Œ 3 ç§’

    t2.Pause();  // æš‚åœ
    sleep(3);    // æš‚åœ 3 ç§’

    t2.Pause();  // æ¢å¤
    sleep(3);    // ç»§ç»­è¿è¡Œ 3 ç§’

    t2.Stop();   // åœæ­¢

    return 0;
}
```

### 4.2 æµ‹è¯•ç»“æœ

**ç¼–è¯‘å‘½ä»¤ï¼š**
```bash
g++ main.cpp Thread.cpp -o test -lpthread -std=c++20
```

**è¿è¡Œè¾“å‡ºï¼š**
```
=== çº¿ç¨‹å°è£…æµ‹è¯•ç¨‹åºï¼ˆç®€åŒ–ç‰ˆï¼‰===

ã€ç®€åŒ–æµ‹è¯•ã€‘æš‚åœå’Œæ¢å¤
----------------------------------------
[ä¸»çº¿ç¨‹] å¯åŠ¨çº¿ç¨‹...
[ä»»åŠ¡2] çº¿ç¨‹å¯åŠ¨
[ä»»åŠ¡2] å·¥ä½œä¸­... 1/20
[ä»»åŠ¡2] å·¥ä½œä¸­... 2/20
[ä»»åŠ¡2] å·¥ä½œä¸­... 3/20
[ä»»åŠ¡2] å·¥ä½œä¸­... 4/20
[ä¸»çº¿ç¨‹] å‡†å¤‡æš‚åœçº¿ç¨‹ï¼
[ä¸»çº¿ç¨‹] çº¿ç¨‹å·²æš‚åœï¼Œç­‰å¾…3ç§’...
â† ä»»åŠ¡åœæ­¢è¾“å‡ºï¼ˆæš‚åœç”Ÿæ•ˆï¼‰
[ä¸»çº¿ç¨‹] å‡†å¤‡æ¢å¤çº¿ç¨‹ï¼
[ä»»åŠ¡2] å·¥ä½œä¸­... 5/20    â† ç»§ç»­æ‰§è¡Œ
[ä»»åŠ¡2] å·¥ä½œä¸­... 6/20
[ä»»åŠ¡2] å·¥ä½œä¸­... 7/20
[ä¸»çº¿ç¨‹] å‡†å¤‡åœæ­¢çº¿ç¨‹...
[ä¸»çº¿ç¨‹] Stop() å®Œæˆ

=== æµ‹è¯•å®Œæˆäº†2333ï¼===
```

**éªŒè¯ç»“æœï¼š**

| åŠŸèƒ½ | é¢„æœŸ | å®é™… | çŠ¶æ€ |
|------|------|------|------|
| å¯åŠ¨çº¿ç¨‹ | æˆåŠŸå¯åŠ¨ | âœ… æˆåŠŸ | âœ… |
| æ‰§è¡Œä»»åŠ¡ | é¡ºåºè¾“å‡º 1-20 | âœ… æ­£å¸¸ | âœ… |
| æš‚åœ | ä»»åŠ¡åœæ­¢è¾“å‡º | âœ… åœæ­¢ 3 ç§’ | âœ… |
| æ¢å¤ | ä»ç¬¬ 5 ä¸ªç»§ç»­ | âœ… ä» 5 å¼€å§‹ | âœ… |
| åœæ­¢ | çº¿ç¨‹ç»ˆæ­¢ | âœ… æ­£å¸¸ç»ˆæ­¢ | âœ… |

---

## äº”ã€å…³é”®é—®é¢˜ä¸è§£ç­”

### 5.1 ä¸ºä»€ä¹ˆä¸ç›´æ¥ç”¨ std::threadï¼Ÿ

**å¯¹æ¯”ï¼špthread vs std::thread**

| ç‰¹æ€§ | pthread | std::thread | é€‰æ‹© |
|------|---------|------------|------|
| **ä¿¡å·æ§åˆ¶** | âœ… pthread_kill | âŒ ä¸æ”¯æŒ | pthread |
| **æš‚åœ/æ¢å¤** | âœ… å¯å®ç° | âŒ æ— æ³•å®ç° | pthread |
| **è·¨å¹³å°** | âŒ Linux only | âœ… è·¨å¹³å° | pthread |
| **åº•å±‚æ§åˆ¶** | âœ… å®Œå…¨æ§åˆ¶ | âŒ å—é™ | pthread |

**ç»“è®ºï¼š**
- **std::thread**ï¼šé€‚åˆç®€å•çš„ä»»åŠ¡å¹¶å‘
- **pthread**ï¼šé€‚åˆéœ€è¦ç²¾ç»†æ§åˆ¶çš„åœºæ™¯ï¼ˆå¦‚æš‚åœ/æ¢å¤ï¼‰

---

### 5.2 æ‰€è°“çš„"æš‚åœ"æ˜¯çœŸæ­£çš„æŒ‚èµ·å—ï¼Ÿ

**ç­”ï¼šä¸æ˜¯ï¼Œæ˜¯"ç©ºè½¬å¾ªç¯"ã€‚**

**æœ¬è´¨ï¼š**
```cpp
while (m_bpaused) {  // ä¸åœæ£€æŸ¥æ ‡å¿—
    usleep(1000);    // ç¡çœ  1ms
}
```

**ä¸ºä»€ä¹ˆä¸æ˜¯çœŸæ­£æŒ‚èµ·ï¼Ÿ**
- Linux æ²¡æœ‰ pthread_suspend API
- Windows çš„ SuspendThread ä¹Ÿä¸æ¨èä½¿ç”¨ï¼ˆå®¹æ˜“æ­»é”ï¼‰

**CPU å¼€é”€åˆ†æï¼š**
```
æ¯ 1ms æ£€æŸ¥ä¸€æ¬¡
    â†“
1 ç§’æ£€æŸ¥ 1000 æ¬¡
    â†“
æ¯æ¬¡ï¼šè¯»å–å˜é‡ï¼ˆå‡ çº³ç§’ï¼‰+ usleepï¼ˆè®©å‡º CPUï¼‰
    â†“
å®é™… CPU å ç”¨ï¼š< 0.01%ï¼ˆå¯å¿½ç•¥ï¼‰
```

**è®¾è®¡å“²å­¦ï¼š**
- **ç®€å•å®ç”¨**ï¼šè™½ä¸å®Œç¾ï¼Œä½†è¶³å¤Ÿå¥½
- **æ— ä¾µå…¥**ï¼šç”¨æˆ·ä»»åŠ¡æ— éœ€é…åˆ
- **æ€§èƒ½å¯æ¥å—**ï¼šCPU å¼€é”€å¯å¿½ç•¥

---

### 5.3 ä¸ºä»€ä¹ˆ Stop() å…ˆç­‰ 100msï¼Ÿ

**è®¾è®¡ï¼šç¤¼è²Œç­‰å¾… + å¼ºåˆ¶ç»ˆæ­¢**

```cpp
int Stop() {
    m_thread = 0;  // é€šçŸ¥çº¿ç¨‹é€€å‡º

    pthread_timedjoin_np(thread, NULL, 100ms);  // ç¤¼è²Œç­‰å¾…

    if (timeout) {
        pthread_kill(SIGUSR2);  // å¼ºåˆ¶ç»ˆæ­¢
    }
}
```

**ä¸ºä»€ä¹ˆæ˜¯ 100msï¼Ÿ**

| æ—¶é—´ | è¯´æ˜ |
|------|------|
| **10ms** | å¤ªçŸ­ï¼Œèµ„æºæ¸…ç†æ¥ä¸åŠ |
| **100ms** | âœ… **é»„é‡‘å€¼**ï¼šå¤§éƒ¨åˆ†çº¿ç¨‹å¤Ÿç”¨ï¼Œç”¨æˆ·æ— æ„ŸçŸ¥ |
| **1ç§’** | å¤ªé•¿ï¼Œç”¨æˆ·ä¼šæ„Ÿè§‰å¡é¡¿ |

**ä¼˜é›…é€€å‡ºçš„æ„ä¹‰ï¼š**

```cpp
// çº¿ç¨‹å†…éƒ¨æœ‰æœºä¼šæ‰§è¡Œæ¸…ç†å·¥ä½œ
void MyTask() {
    FILE* f = fopen("log.txt", "w");
    int* buffer = new int[10000];

    while (true) {
        if (m_thread == 0) break;  // â† æ£€æŸ¥é€€å‡ºæ ‡å¿—
        DoWork();
    }

    // 100ms å†…å¯ä»¥å®Œæˆè¿™äº›ï¼š
    fclose(f);       // âœ… å…³é—­æ–‡ä»¶
    delete[] buffer; // âœ… é‡Šæ”¾å†…å­˜
    SaveState();     // âœ… ä¿å­˜çŠ¶æ€
}
```

**ç±»æ¯”ï¼š**
- ğŸ’¡ **100ms** = å…¬å¸è£å‘˜ç»™ 2 å‘¨äº¤æ¥æ—¶é—´
- ğŸ’¡ **ç›´æ¥æ€æ­»** = ä¿å®‰ç›´æ¥è½°èµ°

---

## å…­ã€è°ƒè¯•æŠ€å·§æ€»ç»“

### 6.1 è°ƒè¯•è¾“å‡ºç­–ç•¥

**åˆ†é˜¶æ®µæ·»åŠ è°ƒè¯•è¾“å‡ºï¼š**

```cpp
// é˜¶æ®µ1ï¼šéªŒè¯æµç¨‹
printf("[è°ƒè¯•] çº¿ç¨‹ %lu æ’å…¥åˆ° map\n", m_thread);
printf("[è°ƒè¯•-ThreadEntry] çº¿ç¨‹å…¥å£å¼€å§‹æ‰§è¡Œ\n");
printf("[è°ƒè¯•] Sigaction è¢«è°ƒç”¨ï¼Œä¿¡å·=%d\n", signo);

// é˜¶æ®µ2ï¼šéªŒè¯å®Œæˆåç§»é™¤
// ç§»é™¤æ‰€æœ‰ [è°ƒè¯•] è¾“å‡º

// é˜¶æ®µ3ï¼šä¿ç•™å…³é”®é”™è¯¯è¾“å‡º
if (ret != 0) {
    printf("[é”™è¯¯] æ“ä½œå¤±è´¥: %d\n", ret);
}
```

---

### 6.2 è¿œç¨‹è°ƒè¯•æŠ€å·§

**å·¥å…·é€‰æ‹©ï¼š**

| å·¥å…· | é€‚ç”¨åœºæ™¯ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|---------|------|------|
| **VS F5** | éœ€è¦æ–­ç‚¹è°ƒè¯• | åŠŸèƒ½å¼ºå¤§ | ä¿¡å·ä¼šä¸­æ–­ |
| **Ctrl + F5** | å¿«é€Ÿè¿è¡Œ | æ— è°ƒè¯•å™¨å¹²æ‰° | è¾“å‡ºåœ¨è¿œç¨‹ |
| **SimpleRemote** | ç»ˆç«¯æ“ä½œ | ç›´è§‚ï¼ŒçœŸå®ç¯å¢ƒ | éœ€è¦é¢å¤–é…ç½® |

**æ¨èæµç¨‹ï¼š**
1. **å¼€å‘é˜¶æ®µ**ï¼šVS F5ï¼ˆè®¾æ–­ç‚¹ã€æŸ¥å˜é‡ï¼‰
2. **æµ‹è¯•é˜¶æ®µ**ï¼šSimpleRemote ç»ˆç«¯ï¼ˆçœŸå®ç¯å¢ƒï¼‰
3. **ç”Ÿäº§ç¯å¢ƒ**ï¼šç›´æ¥åœ¨ Linux è¿è¡Œ

---

### 6.3 ä¿¡å·ç›¸å…³è°ƒè¯•

**GDB é…ç½®ï¼š**

```bash
# ~/.gdbinit
handle SIGUSR1 nostop noprint pass
handle SIGUSR2 nostop noprint pass
```

**æ‰‹åŠ¨æµ‹è¯•ä¿¡å·ï¼š**

```bash
# å¯åŠ¨ç¨‹åº
./test &
PID=$!

# å‘é€ä¿¡å·æµ‹è¯•
kill -USR1 $PID  # æµ‹è¯•æš‚åœ
sleep 3
kill -USR1 $PID  # æµ‹è¯•æ¢å¤
sleep 3
kill -USR2 $PID  # æµ‹è¯•å¼ºåˆ¶é€€å‡º
```

---

## ä¸ƒã€æ€§èƒ½ä¸ä¼˜åŒ–

### 7.1 å†…å­˜å ç”¨

**å•ä¸ª CThread å¯¹è±¡ï¼š**

```cpp
sizeof(std::function<int()>)    // ~32 å­—èŠ‚
sizeof(pthread_t)                // 8 å­—èŠ‚
sizeof(bool)                     // 1 å­—èŠ‚
sizeof(static map)               // å…±äº«ï¼ˆä¸è®¡å…¥ï¼‰
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æ€»è®¡ï¼š~48 å­—èŠ‚/çº¿ç¨‹
```

**1000 ä¸ªçº¿ç¨‹ï¼š~48KBï¼ˆå¯å¿½ç•¥ï¼‰**

---

### 7.2 CPU å ç”¨

**æš‚åœçŠ¶æ€ï¼š**
```
æ¯ 1ms æ£€æŸ¥ä¸€æ¬¡ Ã— 1000 çº¿ç¨‹ = 1000 æ¬¡/ms
æ¯æ¬¡ï¼šè¯»å– + æ¯”è¾ƒ + usleep
CPU å ç”¨ï¼š< 0.1%
```

**è¿è¡ŒçŠ¶æ€ï¼š**
```
æ— é¢å¤–å¼€é”€ï¼ˆç”¨æˆ·ä»»åŠ¡æ­£å¸¸æ‰§è¡Œï¼‰
```

---

### 7.3 å¯èƒ½çš„ä¼˜åŒ–

**ä¼˜åŒ–1ï¼šè‡ªé€‚åº”ç¡çœ **

```cpp
// å½“å‰ï¼šå›ºå®š 1ms
usleep(1000);

// ä¼˜åŒ–ï¼šæ ¹æ®æš‚åœæ—¶é•¿è°ƒæ•´
int sleep_time = 1000;  // åˆå§‹ 1ms
while (m_bpaused) {
    usleep(sleep_time);
    if (sleep_time < 10000) {
        sleep_time *= 2;  // é€æ¸å¢åŠ åˆ° 10ms
    }
}
```

**ä¼˜åŒ–2ï¼šæ¡ä»¶å˜é‡ï¼ˆçœŸæ­£çš„é˜»å¡ï¼‰**

```cpp
std::mutex m_mutex;
std::condition_variable m_cv;

Pause() {
    std::unique_lock<std::mutex> lock(m_mutex);
    m_bpaused = true;
}

Sigaction() {
    std::unique_lock<std::mutex> lock(m_mutex);
    m_cv.wait(lock, [this] { return !m_bpaused; });
}
```

**æƒè¡¡ï¼š**
- **å½“å‰æ–¹æ¡ˆ**ï¼šç®€å•ã€å¯é ã€æ€§èƒ½è¶³å¤Ÿ
- **ä¼˜åŒ–æ–¹æ¡ˆ**ï¼šæ›´é«˜æ•ˆï¼Œä½†å¤æ‚åº¦å¢åŠ 

**æœ€ä½³å®è·µï¼š**
> åœ¨æ€§èƒ½è¶³å¤Ÿæ—¶ï¼Œä¼˜å…ˆé€‰æ‹©ç®€å•æ–¹æ¡ˆ

---

## å…«ã€å¸¸è§é”™è¯¯ä¸é™·é˜±

### 8.1 ç¼–è¯‘é”™è¯¯

#### é”™è¯¯1ï¼šæ‰¾ä¸åˆ° std::forward

```cpp
error: 'forward' is not a member of 'std'
```

**åŸå› ï¼š** ç¼ºå°‘å¤´æ–‡ä»¶

**è§£å†³ï¼š**
```cpp
#include <utility>  // std::forward
```

---

#### é”™è¯¯2ï¼šå‚æ•°åŒ…æ•è·è­¦å‘Š

```
warning: pack init-capture only available with '-std=c++20'
```

**è§£å†³ï¼š**
```bash
g++ ... -std=c++20  # ä½¿ç”¨ C++20
```

---

### 8.2 è¿è¡Œæ—¶é”™è¯¯

#### é”™è¯¯1ï¼šä¿¡å·é»˜è®¤ç»ˆæ­¢ç¨‹åº

**ç°è±¡ï¼š** ç¨‹åºæ”¶åˆ° SIGUSR1 åå´©æºƒ

**åŸå› ï¼š** ä¿¡å·æ³¨å†Œæ™šäºä¿¡å·å‘é€ï¼ˆç«æ€æ¡ä»¶ï¼‰

**è§£å†³ï¼š**
```cpp
Start();
sleep(1);  // ç­‰å¾…ä¿¡å·æ³¨å†Œå®Œæˆ
Pause();
```

---

#### é”™è¯¯2ï¼šmap ä¸­æ‰¾ä¸åˆ°çº¿ç¨‹

**ç°è±¡ï¼š** Sigaction ä¸­ `m_mapThread.find()` è¿”å› end()

**åŸå› ï¼š** Start() ä¸­å¿˜è®°æ’å…¥ map

**è§£å†³ï¼š**
```cpp
Start() {
    pthread_create(...);
    m_mapThread[m_thread] = this;  // â† å¿…é¡»æœ‰
}
```

---

### 8.3 è°ƒè¯•é™·é˜±

#### é™·é˜±1ï¼šVS è°ƒè¯•å™¨æ‹¦æˆªä¿¡å·

**ç°è±¡ï¼š** ç¨‹åºåœåœ¨ä¿¡å·å¤„ï¼Œéœ€è¦ç‚¹"ç»§ç»­"

**ä¸æ˜¯ä»£ç é—®é¢˜ï¼š** æ˜¯è°ƒè¯•å™¨çš„ä¿æŠ¤æœºåˆ¶

**è§£å†³ï¼š** ä½¿ç”¨è¿œç¨‹ç»ˆç«¯è¿è¡Œï¼Œæˆ–é…ç½®è°ƒè¯•å™¨

---

#### é™·é˜±2ï¼šprintf è¾“å‡ºç¼“å†²

**ç°è±¡ï¼š** printf è¾“å‡ºä¸åŠæ—¶æ˜¾ç¤º

**è§£å†³ï¼š**
```cpp
printf("...");
fflush(stdout);  // ç«‹å³åˆ·æ–°
```

æˆ–ä½¿ç”¨æ— ç¼“å†²ï¼š
```cpp
setbuf(stdout, NULL);  // main() å¼€å¤´
```

---

## ä¹ã€å­¦ä¹ æ”¶è·

### 9.1 æŠ€æœ¯æŒæ¡

âœ… **C++ é«˜çº§ç‰¹æ€§**
- ä¸‡èƒ½å¼•ç”¨ä¸å®Œç¾è½¬å‘çš„å®æˆ˜åº”ç”¨
- Lambda æ•è·çš„ç»†èŠ‚ï¼ˆå°¤å…¶æ˜¯å‚æ•°åŒ…æ•è·ï¼‰
- std::function çš„æ­£ç¡®ä½¿ç”¨
- é™æ€æˆå‘˜å˜é‡çš„è·¨ç¼–è¯‘å•å…ƒå®šä¹‰

âœ… **Linux ç³»ç»Ÿç¼–ç¨‹**
- pthread API çš„å®Œæ•´ä½¿ç”¨
- ä¿¡å·æœºåˆ¶çš„æ·±å…¥ç†è§£
- çº¿ç¨‹åŒæ­¥ä¸æ§åˆ¶
- ç«æ€æ¡ä»¶çš„è¯†åˆ«ä¸è§£å†³

âœ… **è®¾è®¡æ¨¡å¼ä¸æ¶æ„**
- é™æ€æ˜ å°„è¡¨æ¨¡å¼
- RAII èµ„æºç®¡ç†
- ç±»å‹æ“¦é™¤çš„å®é™…åº”ç”¨
- æ¥å£è®¾è®¡çš„æƒè¡¡ï¼ˆç®€å• vs å®Œç¾ï¼‰

---

### 9.2 è°ƒè¯•èƒ½åŠ›

âœ… **è¿œç¨‹è°ƒè¯•**
- VS è¿œç¨‹ Linux è°ƒè¯•é…ç½®
- SimpleRemote å·¥å…·ä½¿ç”¨
- GDB ä¿¡å·å¤„ç†é…ç½®

âœ… **é—®é¢˜å®šä½**
- ç«æ€æ¡ä»¶çš„è¯Šæ–­
- è°ƒè¯•å™¨å¹²æ‰°çš„è¯†åˆ«
- ç¼–è¯‘è­¦å‘Šçš„è§£è¯»

âœ… **æµ‹è¯•ç­–ç•¥**
- åˆ†é˜¶æ®µæ·»åŠ è°ƒè¯•è¾“å‡º
- ç®€åŒ–æµ‹è¯•ç”¨ä¾‹
- çœŸå®ç¯å¢ƒéªŒè¯

---

### 9.3 å·¥ç¨‹å®è·µ

âœ… **æŠ€æœ¯é€‰å‹**
- åœ¨"å®Œç¾"å’Œ"å¤Ÿç”¨"ä¹‹é—´æƒè¡¡
- è€ƒè™‘ä»£ç å¤æ‚åº¦ vs åŠŸèƒ½å®Œæ•´æ€§
- ä¼˜å…ˆé€‰æ‹©æ ‡å‡†åº“æ–¹æ¡ˆ

âœ… **ä»£ç è´¨é‡**
- æ·»åŠ å¿…è¦çš„é”™è¯¯æ£€æŸ¥
- ä¿æŒä»£ç ç®€æ´å¯è¯»
- é€‚åº¦æ³¨é‡Šï¼ˆå…³é”®ç‚¹ï¼‰

âœ… **ç‰ˆæœ¬æ§åˆ¶**
- Git æäº¤çš„æœ€ä½³å®è·µ
- æ–‡æ¡£ä¸ä»£ç åŒæ­¥æ›´æ–°

---

## åã€åç»­è®¡åˆ’

### å·²å®Œæˆ âœ…
- [x] ç†è®ºå­¦ä¹ ï¼ˆthread_advanced_concepts.mdï¼‰
- [x] Thread.h å®Œæ•´å®ç°
- [x] Thread.cpp é™æ€æˆå‘˜å®šä¹‰
- [x] æµ‹è¯•ä»£ç ç¼–å†™
- [x] æ‰€æœ‰åŠŸèƒ½éªŒè¯é€šè¿‡
- [x] å®æˆ˜æ€»ç»“æ–‡æ¡£

### ä¸‹ä¸€æ­¥
- [ ] ç§»é™¤è°ƒè¯•è¾“å‡ºï¼Œæäº¤æ­£å¼ç‰ˆæœ¬
- [ ] æ·»åŠ å®Œæ•´æµ‹è¯•å¥—ä»¶ï¼ˆSimpleTaskã€Lambda ç­‰ï¼‰
- [ ] ç»“åˆå®é™…é¡¹ç›®ï¼ˆæ¸¸æˆæœåŠ¡å™¨ï¼‰ä½¿ç”¨
- [ ] å­¦ä¹ çº¿ç¨‹æ± è®¾è®¡
- [ ] ç»§ç»­å…¶ä»–æ¨¡å—ï¼ˆSocketã€Epoll é›†æˆï¼‰

---

## å‚è€ƒèµ„æ–™

### å®˜æ–¹æ–‡æ¡£
- [pthread(7) - Linux manual page](https://man7.org/linux/man-pages/man7/pthreads.7.html)
- [sigaction(2) - Linux manual page](https://man7.org/linux/man-pages/man2/sigaction.2.html)
- [C++ Reference - std::function](https://en.cppreference.com/w/cpp/utility/functional/function)
- [C++ Reference - std::forward](https://en.cppreference.com/w/cpp/utility/forward)

### ä¹¦ç±
- Effective Modern C++ (Scott Meyers) - æ¡æ¬¾ 23-30
- Linux/UNIX ç³»ç»Ÿç¼–ç¨‹æ‰‹å†Œï¼ˆMichael Kerriskï¼‰
- C++ Concurrency in Action (Anthony Williams)

### é¡¹ç›®å‚è€ƒ
- æ˜“æ’­æœåŠ¡å™¨ä»£ç  - 019ï¼šçº¿ç¨‹çš„å°è£…
- æœ¬é¡¹ç›®å‰åºæ–‡æ¡£ï¼šthread_advanced_concepts.md

---

**å­¦ä¹ æ—¥æœŸï¼š** 2025-11-28
**é¡¹ç›®çŠ¶æ€ï¼š** çº¿ç¨‹å°è£…æ¨¡å—å®Œæˆ âœ…
**ä¸‹ä¸€æ­¥ï¼š** æäº¤ Gitï¼Œç»§ç»­å…¶ä»–æ¨¡å—å­¦ä¹ 

---

## é™„å½•ï¼šå®Œæ•´æ–‡ä»¶åˆ—è¡¨

```
D:\VS\GameServerFrameWork1\GameServerFrameWork1\
â”œâ”€â”€ Thread.h                          # çº¿ç¨‹ç±»å¤´æ–‡ä»¶ï¼ˆå®Œæ•´å®ç°ï¼‰
â”œâ”€â”€ Thread.cpp                        # é™æ€æˆå‘˜å®šä¹‰
â”œâ”€â”€ main.cpp                          # æµ‹è¯•ä»£ç 
â”œâ”€â”€ docs/
â”‚   â”œâ”€â”€ thread_advanced_concepts.md   # ç†è®ºç¯‡ï¼ˆå·²å®Œæˆï¼‰
â”‚   â””â”€â”€ thread_implementation_guide.md # å®æˆ˜ç¯‡ï¼ˆæœ¬æ–‡æ¡£ï¼‰
â””â”€â”€ test                              # ç¼–è¯‘åçš„å¯æ‰§è¡Œæ–‡ä»¶
```

**ç¼–è¯‘å‘½ä»¤ï¼š**
```bash
g++ main.cpp Thread.cpp -o test -lpthread -std=c++20
```

**è¿è¡Œï¼š**
```bash
./test
```

---

## è‡´è°¢

æ„Ÿè°¢ï¼š
- **æ˜“æ’­æœåŠ¡å™¨æ•™ç¨‹**ï¼šæä¾›äº†ä¼˜ç§€çš„çº¿ç¨‹å°è£…è®¾è®¡æ€è·¯
- **Claude AI**ï¼šå…¨ç¨‹æŒ‡å¯¼ã€ç­”ç–‘è§£æƒ‘
- **å¼€æºç¤¾åŒº**ï¼šC++ æ ‡å‡†åº“å’Œ pthread åº“çš„ç»´æŠ¤è€…

---

**å®Œ**
